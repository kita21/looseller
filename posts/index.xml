<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on ゆるだら ブログ</title><link>https://looseller.com/posts/</link><description>Recent content in Posts on ゆるだら ブログ</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sun, 04 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://looseller.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>[npm-link] 独自パッケージの開発を爆速に</title><link>https://looseller.com/posts/008-npm-link/</link><pubDate>Sun, 04 Sep 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/008-npm-link/</guid><description>npmのパッケージを自分で開発している時に作成しているパッケージを使用したいことはありますか？
開発している途中で検証する際、npmなどのパッケージレジストリなどにpublishして使用したいprojectでnpm installで引っ張ってくる必要があり手間がかかってしまいます
npm linkを使用することでローカル内だけでnpmのパッケージ検証が可能になります
環境 node -v v18.8.0 npm -v 8.18.0 今回の完成形 private-hello-package // private-hello-package/package.json { &amp;#34;name&amp;#34;: &amp;#34;private-hello-package&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34; }, &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;module&amp;#34; } // index.js const hello = () =&amp;gt; { return &amp;#39;hello world&amp;#39;; }; export { hello }; my-project // my-project/package.</description></item><item><title>[zsh] zshrcのコマンドを解説 随時更新</title><link>https://looseller.com/posts/007-zshrc/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/007-zshrc/</guid><description>setopt prompt_subst プロンプト表示前に変数展開を実行する
autoload zshの関数を使用できるようにする オプション
-U 設定する関数の中でaliasが動作しないようにする -z zsh形式の読み込みを指定している、他のshellが読み込まれないように指定している。 autoloadする関数 vcs_info gitやsvnなどのverison管理システムの方法を取得できる関数
compinit 予測変換が可能になる
colors プロンプトに色をつけることが可能になる
参考文献 .zshrcで見かけるautoloadの意味と使い方 Qiita Zsh — autoload の基本 zshのターミナルにリポジトリの情報を表示してみる</description></item><item><title>[husky, lint-staged] 強制的にコードを綺麗にしよう</title><link>https://looseller.com/posts/006-precommit-husky/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/006-precommit-husky/</guid><description>以前の記事で、コードを綺麗に整形するためのeslintとprettierを説明しました。
しかし一々コードを書いたらリンターとフォーマッターを実施するためにnpmコマンドを実行するのはめんどくさいですよね。複数人で開発している場合はフォーマッターかけることを忘れてしまう人も出てきてしまうため、その後他の人がnpmコマンドでフォーマッターを実施したら忘れてしまった人のフォーマッター差分も発生してしまいプルリクなどが見にくくなってしまいます。
そうならないためにも逐一コードの整形はやっていきたいですね。と言うことでcommitやpush時強制的にコードを綺麗にしましょう！
Info この記事はhuskyとlint-stagedに焦点を当てるため、eslint,prettierの説明はしません。 説明を簡素化させるためにprettierのみinstallしeslintは使用しない 環境 Node: 16.13.2
{ &amp;#34;devDependencies&amp;#34;: { &amp;#34;husky&amp;#34;: &amp;#34;^8.0.1&amp;#34;, &amp;#34;lint-staged&amp;#34;: &amp;#34;^13.0.3&amp;#34;, &amp;#34;prettier&amp;#34;: &amp;#34;^2.7.1&amp;#34; } } 今回の完成形 { &amp;#34;name&amp;#34;: &amp;#34;project-name&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.ts&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;pre-commit&amp;#34;: &amp;#34;lint-staged&amp;#34;, &amp;#34;prepare&amp;#34;: &amp;#34;husky install&amp;#34; }, &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;husky&amp;#34;: &amp;#34;^8.</description></item><item><title>[eslint, prettier] 人によって書き方が違う?それlintで解決できます</title><link>https://looseller.com/posts/005-js-ts-formatter/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/005-js-ts-formatter/</guid><description>人によってコードの書き方がバラバラでプルリクでの確認で口論や宗教戦争が始まる時ありますか？私はありました。
書き方は人それぞれでもコードは動くのでなかなか決着がつかなくて不要なところで疲れてしまうのはとてももったいないです。時間は有限なのです。コードの書き方はlinter/formatterに任せてしまいましょう。
環境 Node: 16.13.2
{ &amp;#34;@typescript-eslint/eslint-plugin&amp;#34;: &amp;#34;^5.30.5&amp;#34;, &amp;#34;@typescript-eslint/parser&amp;#34;: &amp;#34;^5.30.5&amp;#34;, &amp;#34;eslint&amp;#34;: &amp;#34;^8.19.0&amp;#34;, &amp;#34;eslint-config-prettier&amp;#34;: &amp;#34;^8.5.0&amp;#34;, &amp;#34;prettier&amp;#34;: &amp;#34;^2.7.1&amp;#34;, &amp;#34;typescript&amp;#34;: &amp;#34;^4.7.4&amp;#34; } 今回の完成形 // package.json { &amp;#34;name&amp;#34;: &amp;#34;project-name&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.ts&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;lint&amp;#34;: &amp;#34;eslint \&amp;#34;**/*.{js,ts}\&amp;#34;&amp;#34;, &amp;#34;format&amp;#34;: &amp;#34;prettier --write \&amp;#34;**/*.{js,ts}\&amp;#34;&amp;#34; }, &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;@typescript-eslint/eslint-plugin&amp;#34;: &amp;#34;^5.</description></item><item><title>[Notion] NotionでJiraを超えろ！</title><link>https://looseller.com/posts/004-notion-project-template/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/004-notion-project-template/</guid><description>ある日思いました。お金をかけないで複数のプロジェクトを一元管理できるツール欲しいなと。
ということで、最近話題のNotionを使用してとてもいい感じのタスク管理ツールを作成していきたいと思います。
最初に完成品を公開にしているので、説明はいいから使用したいだけの人はどうぞ.
→ 完成品
このテンプレートで何ができるの？ Jiraのようなタスク管理ができる 複数のproject単位で、タスクを管理できる 期限切れやバックログとボード以外の機能も使える ボード、カレンダー、タイムライン(ロードマップ)とタスクについて多くの見方ができる アカウントを共有すればタダでチーム全員のタスク管理できる
(この方法を採用した結果、メンバーによる裏切りタスクデータ破壊は一切の責任を負いません) とこんな感じで我ながら結構よくできていると思います。
では、作成方法を解説していきます。
テンプレートを作成する 適当な名前つける。今回の場合は[Example Project Planning] データベースで**ボードビュー*＊を選択 ついでにデータベース名をProject1にしましょう。絵文字もつけちゃう 左右の余白を縮小をクリック プロバティ追加 label(表示)
プロバティの種類: セレクト
今回の例) derection, design, backend, frontend, sales 優先度(表示)
プロバティの種類: セレクト
今回の例) 低, 中, 高 日時(表示) プロバティの種類: 日付
日付の形式: 年/月/日
時刻の形式: 24時間 assign(表示)
プロバティの種類: セレクト or ユーザー(アカウント一つだと使えない)
今回の例) 田中, 鈴木, jon 終了時刻(非表示)
プロバティの種類: 関数</description></item><item><title>[Homebrew] brewで過去のバージョン使いたいんだけど</title><link>https://looseller.com/posts/003-homebrew-version-managed/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/003-homebrew-version-managed/</guid><description>Homebrewのパッケージをinstallした後にそのversionに問題があり、過去versionを使用したい場合がありますがありますよね？
ってことでHomebrewってバージョン管理できないのって思って調べてみました。
まずは、Homebrewについて←古いですが、結構網羅的に書いてあります。
では、過去versionをinstallする方法ですね
今回は、yqのパッケージを例として説明していきます。
下準備 まずは、yqをinstallします。
$ brew info yq .. ... $ yq -V yq (https://github.com/mikefarah/yq/) version 4.25.1 ここでyqの4.25.1に問題があって、4.24系を使用したいとします。
$ brew install yq@4.24としてももちろんダメです。
$ brew install yq@4.24 Warning: No available formula with the name &amp;#34;yq@4.24&amp;#34;. ==&amp;gt; Searching for similarly named formulae... Error: No similarly named formulae found. ==&amp;gt; Searching for a previously deleted formula (in the last month)... Warning: homebrew/core is shallow clone. To get its complete history, run: git -C &amp;#34;$(brew --repo homebrew/core)&amp;#34; fetch --unshallow Error: No previously deleted formula found.</description></item><item><title>[Docker] マルチステージビルドって？</title><link>https://looseller.com/posts/002-multistage-build/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/002-multistage-build/</guid><description>バックエンドエンジニアは、Dockerに触れる機会が多いと思います。Dockerを使用するにあたり必ずと言っていいほど必要になってくるのが、Dockerfileですね。 なんとなくDockerfileを使用していると気づかないうちにDockerイメージが大きくなってしまい、イメージの容量でPCがいっぱいいっぱいになってしまいます。 せっかくなのでこの記事を読んでDockerイメージを軽くしましょう！
Dockerイメージの容量を減らすことによるメリット PCなどのディスク容量を圧迫しない GCPやAWSなどのストレージ系料金を抑えられる Deploy時間を短縮できる Dockerイメージ小さくしたくなりましたか？したくなりましたね。 Dockerイメージを削減する方法で、COPYやRUNなどの記載を少なくし、レイヤーを削減する方法がありますが、
今回は一番効果の大きいマルチステージビルドを利用した方法を説明します。
まずは、公式のドキュメントです。
公式: マルチステージビルドの利用
んーわたし的にわかりやすく説明しようと思います。
Info マルチステージビルドの文法は Docker Engine 17.05 から導入されています。 例を記載しながら説明します。
今回の例はnpm, typescript, expressで記載されたバックエンドサーバーのプロジェクトとします。
package.jsonの例(他に多くのパッケージがありますが、省略しています)
{ &amp;#34;name&amp;#34;: &amp;#34;example&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;rm -rf dist &amp;amp;&amp;amp; tsc&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;node dist/index.js&amp;#34;, }, &amp;#34;dependencies&amp;#34;: { &amp;#34;express&amp;#34;: &amp;#34;^4.18.1&amp;#34;, ... }, &amp;#34;devDependencies&amp;#34;: { &amp;#34;typescript&amp;#34;: &amp;#34;^4.6.4&amp;#34;, ... } } まず、マルチステージビルドを使用しないでDockerfileを記載してみます。</description></item><item><title>はじめに</title><link>https://looseller.com/posts/001-first-message/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://looseller.com/posts/001-first-message/</guid><description>初めまして、このブログでは業務やプライベートでの技術知見をつらつらを記載していきます。
投稿ペースはかなりぱらつきがありますが、気長にみていただければ嬉しいです。</description></item></channel></rss>